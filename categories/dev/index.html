<!doctype html><html lang=en-us dir=ltr><head class=centered><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><title>dev | Aimee's Note</title><link rel=stylesheet href=/aimeesnotes/css/main.min.aad190ebba69a9e9b561c9c4ba7729fa85478e277fbe3a3b7e2243053fbbc616.css integrity="sha256-qtGQ67ppqem1YcnEuncp+oVHjid/vjo7fiJDBT+7xhY=" crossorigin=anonymous><script src=/aimeesnotes/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body class=centered><header><h1>Aimee's Note</h1><ul class=menu><li><a href=/aimeesnotes/>Home</a></li><li><a href=/aimeesnotes/posts/>Posts</a></li><li><a href=/aimeesnotes/categories/>Categories</a></li><li><a href=/aimeesnotes/tags/>Tags</a></li><li><a href=/aimeesnotes/about/>About</a></li></ul></header><main><h1>dev</h1><h3><a href=/aimeesnotes/%20/categories/dev>[dev]</a>
2023-09-11
<a href=/aimeesnotes/posts/gof-design-patterns/>GoF Design Patterns</a></h3>创建型模式(Creational Patterns) 创建型模式用于处理对象的创建，以适合在给定情况下使用。
单例模式(Singleton Pattern) 保证一个类只有一个实例，并提供一个全局访问点。 e.g. 一个config管理器，确保app种只有一个配置对象 工厂方法模式(Factory Method Pattern) 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 e.g.一个file reader工厂，根据文件类型创建不同的读取器 抽象工厂模式(Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 e.g.一个汽车工厂，可以生产不同类型的汽车和相关零件 建造者模式(Builder Pattern) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 e.g. 一个email构造器，根据需求构造不同的email 原型模式(Prototype Pattern) 通过复制现有对象来创建新对象，而不是使用构造函数。 e.g. 一个图形设计app，可以通过复制现有图形来创造新图形 结构型模式(Structural Patterns) 结构型模式用于处理类和对象的组合，以便在给定情况下形成更大的结构。
适配器模式(Adapter Pattern) 将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 e.g. 一个多国语言翻译器，将不同语言的接口转换为通用的接口 桥接模式(Bridge Pattern) 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 e.g. 一个形状绘制器，支持不同的形状和不同的绘制方案 组合模式(Composite Pattern) 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得客户端可以统一地处理单个对象和组合对象。 e.g. 一个文件系统，支持文件和文件夹的统一操作 装饰器模式(Decorator Pattern) 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。 e.g.一个文本编辑器，可以动态添加字体、颜色等装饰 外观模式(Facade Pattern) 提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，使得子系统更容易使用。 e.g. 一个多媒体播放器，提供播放、停止、调整音量等高层接口 享元模式(Flyweight Pattern) 通过共享来减小内存或存储开销， 通常用于大量相似对象的场景 e.g. 一个文本编辑器，共享相同的字体、颜色对象 代理模式(Proxy Pattern) 为其他对象提供一种代理以控制对这个对象的访问。 e.g.一个虚拟代理，延迟加载大型图像 行为型模式(Behavioral Patterns) 行为型模式主要关注对象之间的通信，以便在系统中更加方便和灵活地沟通。<h3><a href=/aimeesnotes/%20/categories/dev>[dev]</a>
2023-09-11
<a href=/aimeesnotes/posts/oop-design-principles/>OOP Design Principles</a></h3>常见的OOP设计原则(Object-Oriented Programming) 单一职责原则(Single Responsibility Principle - SRP): 每个类应该有一个单一的责任，它只负责一件事情。 e.g.考虑一个咖啡机类，它应该只负责制作咖啡，而不应该包含处理支付的逻辑。将支付逻辑放到另一个类中，以保持单一职责。 开放封闭原则(Open-Closed Principle - OCP): 意味着软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭。 e.g.假设你有一个图形绘制应用，支持绘制不同形状。你可以创建一个基类Shape，然后为每个新形状创建子类，而不需要修改现有的代码。这遵循OCP。 里式替换原则(Liskov Substitution Principle - LSP): 基类的对象应该能够被其子类替代，而不会影响程序的正确性。 e.g. 如果你有一个Bird基类，那么每个继承自Bird的子类（如Sparrow、Penguin）都应该能够替代Bird类，而不会引发错误。 借口隔离原则(Interface Segregation Principle - ISP): 客户端不应该被迫依赖于它们不使用的接口。 e.g. 考虑一个多功能打印机类，但某些客户端只需要打印和扫描功能。你可以将打印和扫描的功能拆分成独立的接口，以便客户端只需实现它们需要的接口。 依赖反转原则(Dependency Inversion Principle - DIP): 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。 e.g. 考虑一个电子设备控制系统，高层模块是控制逻辑，低层模块是硬件驱动。你可以创建一个抽象的接口，让高层模块依赖于这个接口，然后具体的硬件驱动类实现这个接口。</main><footer><p>Copyright 2023. All rights reserved.</p></footer></body></html>